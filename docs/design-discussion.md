# ゲーム設計に関する議論の要点

## 1. 状態管理：不変性（Immutability）の重要性

- **原則**: ゲームの状態（`GameState`）を変更する際、既存の状態を直接書き換えるのではなく、変更箇所のみを新しく作成し、新しい状態オブジェクトを生成する。
- **パフォーマンス**:
  一見、非効率に思えるが、「構造共有」の考え方により、実際にはパフォーマンスの低下はほとんどない。状態のうち、変更されなかった大部分（例：プレイヤーリスト、ボードの大部分）は、新しい状態オブジェクトから参照で共有されるため、コピーのコストは変更された部分のみに限定される。
- **メリット**:
    - **デバッグの容易さ**: 状態が意図せず変更されるバグ（副作用）を防げる。
    - **機能実装の簡潔化**: 「元に戻す（Undo）」機能やゲームのリプレイ再生が簡単に実装できる。
    - **AI開発の効率化**: AIが「もしこの手を打ったらどうなるか」という未来の状態を、現在のゲーム状態を破壊することなく安全にシミュレーションできる。

## 2. ルール実装：プラグイン可能なルール（Strategy パターン）

- **原則**: 「サイコロを振る」「カードをプレイする」といった個々のゲームルールを、それぞれ独立したクラス（オブジェクト）としてカプセル化する。
- **具体例**: `RollingDieRule` というインターフェースに対し、`StandardDieRule`（通常のサイコロ）、`CursedDieRule`
  （呪われた時のサイコロ）といった具体的なルールクラスを実装する。ゲームエンジンは、状況に応じて適切なルールオブジェクトを選択し、実行するだけになる。

## 3. 設計上のトレードオフ

このアプローチには、明確なトレードオフが存在する。

### A) 一元管理されたルール

- **長所**:
    - **理解しやすさ**: 全てのルールが一つの大きな関数やクラスにまとまっているため、ゲーム全体の流れを追いやすい。
- **短所**:
    - **拡張性の低さ**: 新しいルールを追加するたびに、巨大で複雑な既存コードを修正する必要があり、バグを混入させるリスクが高い。
    - **テストの困難さ**: 特定のルールだけをテストすることが難しい。

### B) プラグイン可能なルール（推奨アプローチ）

- **長所**:
    - **高い拡張性**: 新しいルールを新しいファイル（クラス）として追加するだけでよく、既存のコードを修正する必要がない（オープン・クローズドの原則）。
    - **テストの容易さ**: 各ルールを完全に独立させて単体テストできるため、品質を保ちやすい。
- **短所**:
    - **全体像の把握の難しさ**: ルールが分散しているため、「カードをプレイした時に何が起こるか」の全体像を把握するのが難しくなる可能性がある。

## 4. 「全体像の把握の難しさ」への対策

プラグイン方式の短所は、以下の工夫で軽減できる。

- **ルールレジストリ**: 全てのルールオブジェクトを一元的に登録・管理する場所を用意する。これにより、どのようなルールが存在するかの「目次」として機能する。
- **優先度システム**: 複数のルールが同時に適用可能な場合に備え、各ルールに優先度を設定する。
- **明確な命名規則**: `PlayCard_WhenBoardIsEmpty_BonusDrawRule` のように、クラス名やファイル名だけでそのルールの機能が明確にわかるようにする。
- **詳細なロギング**: 「どのルールが評価され、どのルールが選択・実行されたか」をログに出力することで、実行時の実際の流れを簡単に追跡できるようにする。
