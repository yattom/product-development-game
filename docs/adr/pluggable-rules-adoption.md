# プラグイン可能なルール採用に関する決定

## ステータス

承認済み

## コンテキスト

本プロジェクトでは、複雑なゲームロジックと多様なルールバリアントを効率的に管理し、将来的な拡張性、およびルールの追加・変更の容易さを実現する必要がある。特に、ルールの追加・変更の容易さが課題となっていた。

## 決定

**ルール実装におけるプラグイン可能なルール（Strategy パターン）の採用**:
「サイコロを振る」「カードをプレイする」といった個々のゲームルールを、それぞれ独立したクラス（オブジェクト）としてカプセル化する。ゲームエンジンは、状況に応じて適切なルールオブジェクトを選択し、実行する。

## 結果

この決定により、以下のメリットが期待される。

* **高い拡張性**: 新しいルールを新しいファイル（クラス）として追加するだけでよく、既存のコードを修正する必要がない（オープン・クローズドの原則）。
* **テストの容易さ**: 各ルールを完全に独立させて単体テストできるため、品質を保ちやすい。

## 選択肢

### 一元管理されたルール（不採用）

全てのルールを一つの大きな関数やクラスにまとめるアプローチ。

* **長所**: ゲーム全体の流れを追いやすい。
* **短所**:
    * 拡張性の低さ: 新しいルールを追加するたびに、巨大で複雑な既存コードを修正する必要があり、バグを混入させるリスクが高い。
    * テストの困難さ: 特定のルールだけをテストすることが難しい。

## 議論

プラグイン可能なルール方式の採用により、「全体像の把握の難しさ」という短所が懸念される。これに対し、以下の対策を講じることで軽減を図る。

* **ルールレジストリ**: 全てのルールオブジェクトを一元的に登録・管理する場所を用意し、どのようなルールが存在するかの「目次」として機能させる。
* **優先度システム**: 複数のルールが同時に適用可能な場合に備え、各ルールに優先度を設定する。
* **明確な命名規則**: クラス名やファイル名だけでそのルールの機能が明確にわかるようにする（例:
  `PlayCard_WhenBoardIsEmpty_BonusDrawRule`）。
* **詳細なロギング**: 「どのルールが評価され、どのルールが選択・実行されたか」をログに出力することで、実行時の実際の流れを簡単に追跡できるようにする。

これらの対策により、プラグイン方式のメリットを最大限に活かしつつ、デメリットを最小限に抑えることを目指す。
